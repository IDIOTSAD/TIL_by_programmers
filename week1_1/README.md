# week 1_1

### ● 1강 요약 (안녕, 자료구조 & 알고리즘)
> * 자료구조를 왜 배워야 하는가?
> * 리스트가 아닌 어떤 자료구조를 만들면 시간을 줄일 수 있을까?
> * 결국 연산 시간을 줄이기 위한 고민에 대한 해결방안
> * 풀어야 하는 문제의 파악 후, 자료구조의 성질에 맞게 자료구조를 선택
> * 예) 최대값은 정렬하면 찾기가 쉬워짐.
> * 이를 위해서 다양한 알고리즘을 많이 사용함.

### ● 2강 요약 (선형 배열)
> * 선형배열은 일렬로 늘어진 자료형이다. 원소들을 순서대로 정렬해놓음.
> * 대표적으로 리스트가 있다. (배열보단 융통성 있는 자료형)
> * 리스트는 어떠한 자료형이라도, 각 원소의 길이가 달라도 사용할 수 있음.
```
  원소 추가 = .append(원소)
  마지막 원소 제거 = .pop() -> 파라메터가 필요 없음.
  해당 함수의 시간복잡도 : O(1)

  원소 위치 지정 후, 직접 삽입 = .insert(원소 위치 주소)
  원소 위치 지정 후, 직접 삭제 = .del(원소 위치 주소)
  원소 위치 탐색 .index(원소 내용)
  해당 함수의 시간복잡도 : O(1) ~ O(N) -> 맨 끝에서 맨 앞까지
```
### ● 3강 요약 (정렬, 탐색)
> * 파이썬 리스트 정렬 방법
> * 파이썬 내장 함수 = sorted(리스트, 오름차수여부(reverse), key=lambda x: 조건)
> * 만약, 람다를 x['딕셔너리 이름'] 같이 정하면, 딕셔너리에서 해당 이름을 정렬 가능
> * list 함수 = .sort()

* 탐색 알고리즘
```
  1. 선형탐색 -> 리스트 순서대로 찾는 방법 -> 시간복잡도 : O(N)
  2. 이진탐색 -> 리스트가 정렬 되어있을 때 사용
  -> 중간값 비교해서 대상이 작으면 왼쪽으로 줄이고, 크면 오른쪽으로 줄임.
  -> 시간복잡도 O(log N)
```
### ● 4강 요약 (재귀 알고리즘)
> * 재귀 = 하나의 함수에서 자신을 다시 호출하여 작업을 수행하는 것.
> * 이진 탐색의 경우, start와 end의 변화된 부분을 계속 값을 주고 같은 함수로 돌림.
> * 예시) 1~n 까지 더하는 문제는 현재 n과 n-1까지의 더한 값을 더하면 1~n까지의 합임. -> 시간복잡도 O(N)
> * 이를 활용하여 점화식을 세워서 풀면 됨. 재귀는 종료 조건이 필수임.
> * 재귀의 효율은 N이 커질수록 함수호출이 많아지므로 효율은 좋지 못함.

### ● 5강 요약 (재귀 알고리즘 응용)
> * ![image](https://user-images.githubusercontent.com/55529455/154016554-e04a0921-58b5-4fc9-9c5a-d267417106d0.png) -> 조합계산을 구현 (n개의 각각 다른 원소에서 m개 선택)
> * from math import factorial as f 를 이용하여 ![image](https://user-images.githubusercontent.com/55529455/154016780-d83aeb67-3c57-48b8-80e2-34f3e412be0f.png) 로 구현
* n개의 각각 다른 원소에서 m개 선택하는 경우의 수
```
![image](https://user-images.githubusercontent.com/55529455/154017079-2246c6f9-6f12-4c78-a6ab-8466e8f80ea3.png)로 표현이 가능함.
따라서 다음과 같은 점화식을 내릴 수 있음. 
![image](https://user-images.githubusercontent.com/55529455/154017413-d9604711-1f2c-41a2-a3d2-12024792d64b.png)
```
