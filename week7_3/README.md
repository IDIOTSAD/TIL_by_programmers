# 강의 요약

## 자동차 운전 = 조향 및 속도 제어
> * 조향각 제어
> * 직선 차로 = 정면으로 직진
> * 곡선 차로 = 차로가 휘어진 방향으로 조향

> * 속도 제어
> * 직선 주로에서는 빠르게 (보다 좋은 랩 타임 기록 가능)
> * 곡선 주로에서는 적절히 느리게 (차선 이탈 방지)

> * 양쪽 차선의 위치를 찾아, 차선의 중간값을 구하고, 화면의 중앙과 비교해서 그 차이만큼 핸들 (조향각) 꺽기
> -> 바로 앞의 차선 위치 찾기

> * 인식된 양쪽 차선의 중점을 보고, 카메라가 차량의 중앙에 있다면, 중앙 지점의 거리차이에 따라 조향 정도를 설정
> * ex) 5픽셀 차이나면 5도 선회, 10픽셀 차이나면 10도 선회

> * 카메라를 통한 차선 인식의 한계점들
> * 빛, 그늘, 반사광, 장애물 때문에 차선이 가리는 경우
> * 급 커브 등 차선이 시야에서 벗어나 안보이는 경우.

> * 차선 인식에 오류가 생기면
> * 조향각 변동이 심해진다 = 핸들을 확확 꺽는 것과 동일
> * 안정적인 주행을 위해선 부드러운 핸들링이 필요함 (조금 둔하게) 조향각 각에 대한 필터를 수행.

> * 조향각에 따른 필터링
> * 카메라 - 차선 찾기 - 조향각 계산 - 필터 - 모터제어 (필터를 통해 차량의 좌우가 심하게 안흔들리게.

> * 간단한 필터들
> * 평균 필터 - 전체 합의 평균값을 필터로 이용
> * 이동평균 필터 - 다 볼 필요 없이, 중간부터 최근꺼까지 더한 것의 평균
> * 가중 이동평균 필터 - 이동평균 필터에 최근 정보에 가중치를 두어 평균을 계산
> * 저주파 통과 필터 (로우패스필터, 지수 가중 이동 평균) - 가중 이동평균 필터에서 가중치를 제곱을 해서 가중치를 주는 것

> * 핸들링에는 어떤 필터가 이용되나? - 이동평균 필터 (과거 값은 버림), 가중 이동평균 필터(최신 값이 중요)

## 제어 개요
> * Control 기법의 종류
> * Open Loop Control - 컨트롤러의 입력이 다이렉트로 output이 나오는 것.
> * Closed Loop Control - output을 하면서 나오는 Measuring Element를 통해서 체크하여 원하는 output을 나올때까지 반복
> * -> 센서 등을 통해 데이터를 수집하고, 수집된 데이터를 기반으로 반복적인 피드백으로 제어하는 기법
> * -> 대표적인 기법이 PID Control

> * 피드백 제어
> * 프로세스를 거쳐서 나온 아웃풋이 인풋에영향을 미치는 루프
> * 자동차의 속도를 높이는 on/off 버튼이 있을 때, 60km 로 달릴 수 있는가?
> -> 정답은 달릴 순 있지만, on/off가 반복되면서 60km에 수렴하지 못하고 진동이 되는 결과가 됨.

> * 단순 on/off 제어
> * 계속해서 on-off 제어를 반복함
> * 출력값의 변화가 매우 큼
> * 시간이 지나도 오차가 줄어들지 않음.

> * PID 제어기
> * 비례, 적분, 미분의 조합으로 적절한 값을 도출하는 기법
> * 제어 대상의 목표값과 출력값과의 차이로 제어값을 계산

> * PID 주요 용어
> * 오버 슈트 = 최종 정상상태 값을 넘어서는 상승 오차
> * 피크 시간 = 가장 큰 overshoot가 발생 했을 때 시간
> * 상승 시간 = output의 0.1 ~ 0.9까지 이를 때 걸리는 시간
> * 정착 시간 = 최종 정상상태에 도달하는 시간

![image](https://user-images.githubusercontent.com/55529455/160755719-fdf9c6b1-4b15-47d9-83f8-f33c64c5d980.png)
![image](https://user-images.githubusercontent.com/55529455/160755743-3aba0395-0e4a-4bf9-82a5-29160b8ede39.png)
![image](https://user-images.githubusercontent.com/55529455/160765244-a3c76c2c-ec2b-4b3a-a2cb-28fbd4afb7db.png)
![image](https://user-images.githubusercontent.com/55529455/160765573-6fb29642-7b07-41da-94b9-5174d5d52ff9.png)

> * P제어 = 피드백 제어 신호가 오차에 비례하게 만드는 비례 제어기

> * Kp가 클 때 = 오차가 작아도 출력 값이 크게 바뀜
> * 장점 = 빠른 응답속도를 가짐
> * 단점 = 오버슈트가 발생함.

> * Kp가 작을 때 = 오차가 작을수록 출력값이 작게 변함
> * 장점 = 오버슈트가 적게 발생
> * 단점 = 느린 응답속도

> * P 제어기만 사용할 경우 = 정상상태 오차가 발생함
> * 정상상태 오차 = 반응이 일정 수준에 정착한 이후에도 존재하는 오차
> * 정상상태 오차 = (일정 시간이 지난 이후 출력값) - (목표값)

> * ex) PID 제어기가 없을 경우 = 목표값에 도달하지 않고, 진동이 심함.
> * ex) PID 제어기를 넣는 경우
> * 1. P gain 값을 작게 하면, 목표값에 도달하지만, 오버슈트가 생김. 반응 속도가 느림.
> * 2. P gain 값을 크게 하면, 반응속도가 빨라지지만, 정상상태 오차가 발생함.

![image](https://user-images.githubusercontent.com/55529455/160766286-3ec19e54-3757-48db-87b9-cb07747c71fb.png)

> * I제어 = 적분을 이용하여 비례 제어에서 남아있는 오차를 제거하는 제어 방법
> * 출력값이 목표값에 빠르게 도달하고 수렴하게 함.

> * Ki가 클 때 = 누적 오차가 빠르게 증가함.
> * 장점 = 빠른 응답속도를 가짐
> * 단점 = 오버슈트가 크게 발생함.

> * Ki가 작을 때 = 누적 오차가 느리게 증가함.
> * 장점 = 오버슈트가 적게 발생
> * 단점 = 느린 응답속도

> * I 제어기 사용할 경우 = 정상상태 오차를 줄일 수 있음.
> * 오차가 없는 상태에도 I 제어기에 남아있는 누적오차 때문에 제어값이 계속 발생함.
> * 따라서 PI, PID 제어기를 많이 사용함.

> * ex) PID 제어기를 넣는 경우
> * 1. I gain 값을 크게 하면, 반응속도가 빨라지지만, 정상상태 오차가 없어지지만, 오버슈트가 크게 발생함.

![image](https://user-images.githubusercontent.com/55529455/160767010-ff7c1d41-d216-4460-9bb1-fe1519c18d39.png)

> * D제어 = 미분을 이용하여 진동을 줄이고 안정성을 향상하는 제어 방법
> * 급격한 출력값의 변동이 발생할 때 급격하게 변하지 않도록 함.
> * 오차가 상수일 경우 D제어기의 출력은 0이 되어 정상상태 오차를 줄일 수 있음. - 일반적으로 D 제어기만 사용하지 않음.
> * 특정 신호가 급변하는 경우 미분 제어기의 출력이 급격하게 커져 시스템을 파괴하는 경우도 있음.
> * 접선의 기울기를 통해서 오차를 줄임 = 즉, 접선의 기울기가 급변하게 된다면 위험함.

> * Kd가 클 때
> * 장점 = 오버슈트가 작게 발생함.
> * 단점 = 신호가 급변하게 되면 시스템을 파괴 할 수 있음.

> * Kd가 작을 때
> * 장점 = 신호가 급변하더라도 적절한 피드백이 가능함.
> * 단점 = 오버슈트가 크게 발생함.

> * I 제어기 사용할 경우 = 시스템의 안정도를 증가 시킬 수 있음.
> * 미분이 불가능한 오차인 경우, 적절한 제어가 안될 수 있음.

> * ex) PID 제어기를 넣는 경우
> * 1. D gain 값을 크게 하면, 오버슈트가 감소함.

![image](https://user-images.githubusercontent.com/55529455/160768875-b6081118-b64d-436a-8272-436587eb6e06.png)
![image](https://user-images.githubusercontent.com/55529455/160768934-d8b4671f-361a-4f00-96ae-9a76483611a3.png)

> * PID 기반 조향 각 제어
> * 목표지점으로 이동하기 위한 핸들 꺽기
> * CTE 값을 0으로 만들기 위한 작업
> * CTE = 화면의 중앙과 좌우차선의 중점 사이의 간격

![image](https://user-images.githubusercontent.com/55529455/160773839-69201cce-9376-4eef-b2aa-71adb9b4913d.png)
![image](https://user-images.githubusercontent.com/55529455/160773906-f0f9ca40-18df-4013-9232-fbc241cb7b8f.png)
![image](https://user-images.githubusercontent.com/55529455/160774108-1562dc8c-8b27-4ff4-80c2-5236585db2e9.png)
![image](https://user-images.githubusercontent.com/55529455/160774917-6161dedc-a191-4fc2-b4a1-327fe40ca34e.png)

> * 화면의 중앙과 좌우 차선의 중점과의 차이를 CTE(error)값으로 설정
> * CTE 값을 인자로 넘겨 PID 계산을 수행함.

![image](https://user-images.githubusercontent.com/55529455/160775022-608baeb9-3a21-4181-914d-07d4519446df.png)






