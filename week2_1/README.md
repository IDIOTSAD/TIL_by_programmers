# week 2_1

### ● 1강 요약 (리눅스의 역사, 배포판)
> * 유닉스, 리눅스의 역사를 배워야 하는 이유
> 1. 표준안(standard)의 존재 의미를 알려준다.
> * -> 표준화된 지식과 규격은 호환성을 높이고, 효율적으로 업무를 할 수 있음. -> 나사의 크기
> 2. 지금도 표준화 이전의 세계가 존재한다.
> * -> 무질서하고 국제 표준 및 업계 표준을 무시한 문서로 배우면 큰일.
> 3. 인터넷 검색에서 나오는 출처가 의심스러운 문서에 주의하자.
> * -> 검색 포털에서는 틀린 내용도 많음. -> 이를 구분하기 힘듬.
> * ### 따라서, 항상 표준 문서와 공식 문서를 먼저 보는 습관을 들이자.
> 4. 인과관계, 상관관계를 이해할 수 있게 된다.
> * -> 왜 이러한 규격이 나오게 된 인과관계를 알게되면, 현재 사용되는 기술이 변화하는 것을 볼 수 있다.
> * -> 테크닉만 아니라, 역사적 배경과 철학을 알아야 한다.
> * 기술의 발전은 어떤 "결핍"을 해결하기 위해 만들어진다.
> * -> 기존의 것을 향상시키거나, 새로 만든다.

> * 표준 이전의 무질서한 세계
> * -> POSIX, X/Open, SUS : 현재 사용되는 표준
> * BSD, SysV : 과거 업계 표준

> * C언어와 UNIX/Linux 관계
> * -> ANSI C -> C99 : ISO/IEC 9899
> * -> C언어는 UNIX를 만들기 위해 탄생한 언어
> * UNIX, Linux의 호환이유는 표준덕부ㄴ
> * Linux 배포판 : 레드헷, 데비안

> ### 키포인트
> * 다양한 표준을 기억하고, 메모한다. -> 표준을 이용하면, 호환성을 보장하는것
> * 컴퓨터 시스템에서 "개방적 호환성"은 "교환"의 효율을 높인다. -> 개방적인 표준이 주는 호환성의 장점 상기.
> * -> 표준을 근거로 만들어지는 SW, HW의 다양한 조합이 호환된다는 보장 -> 같은 규격으로 경쟁하니 가격과 품질 상승.
> * 공식 문서
> * UNIX : www.opengroup.org
> * Linux redhat : access.redhat.com
> * linux foundation : www.linuxfoundation.org

> * ### MAC 프로젝트 : Multics
> * GE, Bell lab(AT&T), MIT AI Lab의 MAC* 프로젝트의 산물
> * 운영체제의 복잡한 기능은 감추고, 시분할, 페이지/세그먼트 메모리 관리, 프로세스 관리, 파일시스템... 등등
> * 그러나 Multics 프로젝트는 망했고, Ken Topmson이라는 사람이 UNIX를 만들기 시작.
> * Ken Topmson은 UNIX를 게임용으로 만들었다. -> 직접 만든 게임을 빠르게 동작하기 위해서 UNIX를 설계.
> * DEC 운영체제를 밀고, UNIX를 설치 할 정도로 성공
> * 하지만, 어셈블리어로 작성하기 때문에, 새로운 제품이 나오면 재작성을 해야함.
> * 데니스 리치는 브라이언 커닝이 B언어를 개량하여 C언어를 개발하게 됨. -> 73년에 C언어로 된 UNIX 배포.

> * UNIX를 C언어로 작성하였을때의 장점
> * 하드웨어가 달라져도 rebuild, 수정으로 포팅이 가능함.
> * 그 결과 UNIX는 PDP-11, VAX 이후의 기계에도 보급.
> * 의도치 않게 C언어는 어셈블리어의 몰락을 가져오게 됨. -> 어떤 프로그램 언어가 발전하면 다른 하나는 도태됨.

> * C언어의 장점
> * 고급언어지만, 어셈블리어와 버금가는 성능 -> 어셈블리어로 변환하여 컴파일하기 때문
> * 낮은 추상화 지원 -> stdio, file 객체
> * 저수준의 하드웨어 조작 가능
> * 쉬운 언어적 특성 -> 지금은 쉬울까..?
> * C언어의 국제표준 = ISO/IEC 9899
> * ANSI-C(C89) = 89년도 표준
> * C99 = 99년도 표준 -> 현재 산업계의 실직적 표준
> * C11 = 11년도 표준
