# week 1_2

### ● 12강 요약 (수식의 후위 표기법)
> * 우리가 흔히 쓰는 수식 표기법은 중위 표기법
> * 연산자를 뒤로 밀어내고, 피연산자를 앞으로 밀어서 표기한다.
> * 후위 표기법은 중위 표기법 보다 컴퓨터가 계산하기 쉬워짐.
> * 해당 표기법을 구현하기 위해서 스택을 이용하게 됨.
* 후위 표기법 구현 방법
```
* 피연산자가 나오면 문자열에 추가함.
* 연산자가 나오면 스택에 넣는다.
* 만약 스택에 연산자가 있으면 스택에 있는 모든 연산자와 비교한다.
* 비교했을 때, 스택에 있는 연산자가 우선 순위가 높으면, 꺼내서 문자열에 추가한다.
* 여는 괄호가 있으면 무조건 넣는다.
* 닫는 괄호가 있으면 스택에서 여는 괄호가 나올때까지 연산자를 빼서 문자열에 추가한다.
(A + B) * (C + D)를 후위 표기법으로 하면 -> A B + C D + *
```
### ● 13강 요약 (후위 표기 수식 계산)
> * 중위 표기법 = 연산자가 피연산자 사이에 위치
> * 후위 표기법 = 연산자가 피연산자 뒤에 위치
* 후위 표기법 계산 코딩 구현 방법
```
* 피연산자가 나오면 스택에 추가함.
* 연산자가 나오면 스택에 있는 피연산자를 2개 꺼내서 계산한다. (연산자에 맞추어)
* 계산한 값을 스택에 다시 넣는다.
```
### ● 14강 요약 (큐)
> * 큐는 데이터 원소를 한 줄로 늘어세우는 자료구조
> * 자료를 보관할 수 있는 선형 구조
> * 단, 넣을 때는 뒤쪽에서 밀어넣고, 꺼낼 때는 앞에서만 꺼냄.
> * 선입선출 (FIFO) 특징을 가지는 선형 자료구조
* 큐의 동작 그림
* ![image](https://user-images.githubusercontent.com/55529455/154265211-95ec3aef-f023-4e79-a4d7-35e6a910edb3.png) ![image](https://user-images.githubusercontent.com/55529455/154265270-55946252-fb53-4de4-a036-8135888638b7.png)
> * 큐의 추상적 자료구조 구현
> 1. 배열을 이용한 구현 -> Python 리스트와 함수를 사용함.
> 2. 연결 리스트를 이용하여 구현 -> 저번 시간에 배운 양방향 연결리스트
> * 큐의 시간복잡도
> * size() - 크기구하는 함수 - O(1)
> * isEmpty() - 비어있는지 확인하는 함수 - O(1)
> * enqueue() - 삽입하는 함수 - O(1)
> * dequeue() - 삭제하는 함수 - O(N)
> * peek() - 맨 앞의 자료를 불러오는 함수 - O(1)

### ● 15강 요약 (환형 큐)
> * 큐는 데이터 원소를 한 줄로 늘어세우는 자료구조
> * 자료를 보관할 수 있는 선형 구조
> * 단, 넣을 때는 뒤쪽에서 밀어넣고, 꺼낼 때는 앞에서만 꺼냄.
![image](https://user-images.githubusercontent.com/55529455/154473156-51d3b375-94b7-4d04-b471-e5e3ed55a374.png)
> * 즉, front를 이용하여 빈자리를 확인하고, rear를 이용하여 빈 자리에 넣을 자리를 확인한다.
> * 환형 큐를 구현하면서 연결리스트 형식으로도 구현 가능함.
> * 하지만, 선형 배열의 장점을 생각하자. -> 구현하기 쉽고, 메모리가 연속되기 때문에 환형 큐를 구현하기 쉬움.
> * 연결리스트의 경우는 연속된 데이터가 아니기 때문에, 구현 할 때 실수를 많이 할 수 있음. 또한, 노드가 끊기면, 해당 메모리를 접근하기 힘듬.

### ● 16강 요약 (우선순위 큐)
> * 큐는 데이터 원소를 한 줄로 늘어세우는 자료구조
> * 만약, 우선순위가 있다면? -> 자신이 원하는거 먼저 넣고 해결할 수 있음. -> 이는 시간 절약을 할 수 있게 됨.
> * 예시) 운영체제의 스케쥴링.
> * 우선순위를 구현하는 방법으로 크게 두가지로 나뉨.
> * 1. 큐에 원소를 넣을 때, 우선순위를 확인하여 정렬하는 방법
> * 2. 큐에서 꺼낼 때, 우선순위가 가장 높은 것을 선택 하는 것.
* 양방향 연결리스트를 이용하여 큐를 구현 하였을 때,
-> 원소를 넣을 때는 O(N)의 시간 복잡도가 걸리게 되므로, 큐의 길이에 비례하게 됨.
-> 원소를 뺄때는 O(1)이 걸리게 됨.
-> 이를 이용하여 알고리즘의 복잡도와 코딩의 편의성을 고려하여 2개의 방법 중 하나를 선택해야함.
-> 양방향 연결리스트의 경우는 1번의 방법이 유리함. -> 2번의 경우는 최악의 경우 O(N^2)이 될 수 있음. 1번의 경우는 최악이 O(N)이기 때문임.

### ● 17강 요약 (트리)
> * 여태까지는 1차원 자료형이고, 트리는 2차원 자료형임.
> * 정점(node)와 간선(edge)를 이용하여 데이터의 배치 형태를 추상화한 자료형.
> * 실제로 데이터베이스 시스템, 검색엔진에 많이 사용됨.
> * 트리는 말 그대로 나무를 생각하되, 거꾸로 되어있는 나무를 생각하자.
* 트리 용어 정리
```
노드 : 데이터
간선 : 노드와 노드가 연결되어 있는 길
루트 노드 : 최상위 노드
리프 노드 : 자식노드가 없는 노드 (끝 노드) - 나무의 이파리 생각하자.
내부 노드 : 자식노드와 부모 노드가 있는 노드 - 나무의 가지 생각하자.
부모 노드 : 자식 노드를 가지는 노드 (자신의 하위 노드가 있음)
자식 노드 : 부모 노드를 가지는 노드 (자신의 상위 노드가 있음)
노드의 수준(level) : 루트를 시작으로 자식노드로 갈 수록, 1 level이 상승함. - 특정 깊이를 가지는 노드의 집합
노드의 차수(degree) : 자식 노드의 개수
노드의 높이(depth) : 해당 노드까지 가는데 걸리는 간선의 개수.
트리의 차수(degree) : 트리가 가지는 노드의 최대 차수
트리의 높이(depth) : 루트 노드에서 가장 깊숙히 있는 노드의 깊이
```
> * 이진트리 = 자식을 최대 2개 가지는 트리를 의미함. -> 자식이 1개 있어도 이진 트리임. 3개 이상부터 안됨. 비어있어도 가능함.
> -> 루트노드 + 왼쪽 서브트리 + 오른쪽 서브트리 (서브트리는 모두 이진트리어야 함.)
> * 포화 이진 트리 = 모든 노드가 (리프 노드 제외) 자식을 2개씩 가지는 트리 (모든 레벨에서 노드들이 모두 채워져 있는 이진 트리)
> * 완전 이진 트리 = 리프 노드의 부모가 1~2개의 자식을 가지고 나머지는 모두 2개의 자식을 가지는 트리
> * 높이가 k인 완전 이진트리
> -> 레벨 k-2 까지는 모든 노드가 2개의 자식을 가진 포화 이진 트리. 레벨 k-1에서는 왼쪽부터 노드가 순차적으로 채워져 있어야 함.

### ● 18강 요약 (이진 트리)
> * 이진트리 = 모든 노드의 차수가 2 이하인 트리.

![image](https://user-images.githubusercontent.com/55529455/154479648-57a6bca1-ca3c-4636-b7a0-d2526347943c.png)

> * size() = 현재 트리에 포함되어 있는 노드의 수, depth() = 현재 트리의 깊이 (height)를 구함.
> * 트리는 정의 자체가 재귀적이기 때문에, 모든 함수들은 재귀적으로 작성이 가능함.
> * 순회 = 이진 트리의 모는 노드를 방문하는 일
> * 순회하는 방법으로 dft(깊이 우선 순회), bft(너비 우선 순회)가 있음.
* 깊이 우선 순회의 종류
> * 중위 순회 (in-order traverasl): 왼쪽 서브트리를 순회한 뒤 노드 x 를 방문, 그리고 나서 오른쪽 서브트리를 순회
> * 전위 순회 (pre-order traversal): 노드 x 를 방문한 후에 왼쪽 서브트리를 순회, 마지막으로 오른쪽 서브트리를 순회
> * 후위 순회 (post-order traversal): 왼쪽 서브트리를 순회, 오른쪽 서브트리를 순회, 그리고 나서 마지막으로 노드 x 를 방문

### ● 19강 요약 (이진 트리의 넓이 우선 순회 BFS)
> * BFS = 넓이 우선 순회
> * 노드의 level 별로 순서대로 노드들을 방문하는 순회방법 - 보편적으로 왼쪽 노드를 우선적으로 방문함.
> * 재귀로는 구현하기가 힘듬. -> 형제 노드가 자식 노드보다 순회 우선권을 가지고 있기 때문에
> * 나중에 방문한다는 것은 -> FIFO의 성질에 어울림 = 큐
* 넓이 우선 순회 알고리즘 구현 방법
```
1. (초기화) traversal <- 빈 리스트, q <- 빈 큐 => 비어있는 큐와 비어있는 리스트를 선언함.
2. 빈 트리가 아니면, root 노드를 큐에 넣음.
3. q가 비어있지 않은 동안 -> 큐의 값이 존재할때까지 반복
3_1. node <- 큐에서 원소를 추출
3_2. 노드 방문 확인
3_3. node의 왼쪽, 오른쪽 자식있으면 큐에 추가함.
4. q가 빈큐가 되면 모든 노드를 방문한 것.
```
### ● 20강 요약 (이진 탐색 트리)
> * 이진 탐색 트리 = 모든 노드에 대해서 왼쪽 서브트리에 있는 데이터는 모두 현재 노드의 값보다 작다.
> -> 또한, 오른쪽 서브트리에 있는 데이터는 모두 현재 노드보다 값보다 크다는 것을 만족하는 이진트리.
> * 이진 탐색의 원리를 이용하기 때문에 시간복잡도 = O(log N) -> 하지만, 항상 O(log N)이 나오지 않음.
> * 이진 탐색 트리의 장점 = 데이터 원소의 추가, 삭제가 쉬움
> * 이진 탐색 트리의 단점 = 공간 소요가 큼
> * 재귀로는 구현하기가 힘듬. -> 형제 노드가 자식 노드보다 순회 우선권을 가지고 있기 때문에
> * 나중에 방문한다는 것은 -> FIFO의 성질에 어울림 = 큐
* 이진 탐색 트리의 삽입 연산
![image](https://user-images.githubusercontent.com/55529455/154501300-b94b2733-dcbc-4b4b-a2b9-b9e9662ae2c8.png)

* 이진 탐색 트리의 연산
```
insert(): 트리에 주어진 데이터 원소를 추가
remove(): 특정 원소를 트리로부터 삭제
lookup(): 특정 원소를 검색 (탐색)
inorder(): 키의 순서대로 데이터 원소들을 나열
min(), max(): 최소 키, 최대 키를 가지는 원소를 각각 탐색
```
### ● 21강 요약 (이진 탐색 트리)
> * 삭제 연산에서 시간복잡도가 O(N)이 나옴. -> 노드를 삭제한 후, 트리에 대한 조정이 필요하기 때문
> -> 또한, 오른쪽 서브트리에 있는 데이터는 모두 현재 노드보다 값보다 크다는 것을 만족하는 이진트리.
> * 이진 탐색의 원리를 이용하기 때문에 시간복잡도 = O(log N) -> 하지만, 항상 O(log N)이 나오지 않음.
> * 이진 탐색 트리의 장점 = 데이터 원소의 추가, 삭제가 쉬움

### ● 22강 요약 (힙)
> * 이진트리의 한 종류 (이진 힙이라고도 함)
> * 루트 노드가 언제나 최소값이나 최대값을 가지는 특징 (최대힙, 최소힙)
> * 완전 이진트리여야 함.
> * 최대힙은 자식의 크기보다 부모의 크기가 큼 -> 재귀적으로 정의됨 (어느 노드를 루트로 하는 서브트리도 모두 최대힙임.)
> * 이진 탐색 트리와의 비교
> * 원소들은 완전히 크기 순으로 정렬 되어 있는가? = 힙은 O, 이진탐색트리는 X
> * 특정 키 값을 가지는 원소를 빠르게 검색 할 수 있는가? = 힙은 O, 이진탐색트리는 X
> * 부가의 제약 조건은 어떤 것인가? = 힙은 완전 이진트리여야 하는 제약이 있음. (n개의 노드 최대 힙의 높이 log(n) + 1, 삽입/삭제/정렬 연산 log(n))
![image](https://user-images.githubusercontent.com/55529455/156114868-a53a4e1d-ecbd-4124-a597-378210698c5d.png)
> * 힙의 삽입 과정 = 트리의 마지막 자리에 새로운 원소를 임시로 저장, 그리고 부모 노드와 키 값을 비교하여 위로, 위로, 이동


### ● 23강 요약 (힙)
> * 힙의 삭제 과정 = 루트 노드의 제거 (이것이 원소들 중 최대값), 트리 마지막 자리 노드를 임시로 루트 노드의 자리에 배채, 자식 노드들과의 값 비교와 아래로, 아래로 이동.
-> (자식은 둘 있을 수도 있는데, 어느쪽으로 이동해야하는지 ? -> 자식 들 중 더 큰 값을 가지는 노드와 자리를 바꿈) 더이상 바꿀 필요가 없거나, 리프 노드에 도달 할 때까지 반복
> * 원소의 개수가 n인 최대 힙에서 최대 원소 삭제 (자식 노드와 대소 비교 2 * log(n), 따라서 최악 복잡도 O(logn)을 가지게 됨.
> * 최대/최소 힙의 응용 = 우선 순위 큐, 힙 정렬
> * 우선 순위 큐 삽입 할 때, 느슨한 정렬을 이루고 있도록 함. O(log n)
> * 우선 순위 큐 삭제 할 때, 최대값을 순서대로 추출. O(log n)
> * 힙 정렬 정렬되지 않은 원소들을 아무 순서로나 최대 힙에 삽입. O(log n)
> * 삽입이 끝나면, 힙이 비게 될때까지 하나씩 삭제. O(log n)
> * 원소들이 삭제된 순서가 원소들의 정렬 순서
> * 정렬 알고리즘의 복잡도 = O(n log n)
