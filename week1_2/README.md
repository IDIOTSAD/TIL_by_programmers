# week 1_2

### ● 12강 요약 (수식의 후위 표기법)
> * 우리가 흔히 쓰는 수식 표기법은 중위 표기법
> * 연산자를 뒤로 밀어내고, 피연산자를 앞으로 밀어서 표기한다.
> * 후위 표기법은 중위 표기법 보다 컴퓨터가 계산하기 쉬워짐.
> * 해당 표기법을 구현하기 위해서 스택을 이용하게 됨.
* 후위 표기법 구현 방법
```
* 피연산자가 나오면 문자열에 추가함.
* 연산자가 나오면 스택에 넣는다.
* 만약 스택에 연산자가 있으면 스택에 있는 모든 연산자와 비교한다.
* 비교했을 때, 스택에 있는 연산자가 우선 순위가 높으면, 꺼내서 문자열에 추가한다.
* 여는 괄호가 있으면 무조건 넣는다.
* 닫는 괄호가 있으면 스택에서 여는 괄호가 나올때까지 연산자를 빼서 문자열에 추가한다.
(A + B) * (C + D)를 후위 표기법으로 하면 -> A B + C D + *
```
### ● 13강 요약 (후위 표기 수식 계산)
> * 중위 표기법 = 연산자가 피연산자 사이에 위치
> * 후위 표기법 = 연산자가 피연산자 뒤에 위치
* 후위 표기법 계산 코딩 구현 방법
```
* 피연산자가 나오면 스택에 추가함.
* 연산자가 나오면 스택에 있는 피연산자를 2개 꺼내서 계산한다. (연산자에 맞추어)
* 계산한 값을 스택에 다시 넣는다.
```
### ● 14강 요약 (큐)
> * 큐는 데이터 원소를 한 줄로 늘어세우는 자료구조
> * 자료를 보관할 수 있는 선형 구조
> * 단, 넣을 때는 뒤쪽에서 밀어넣고, 꺼낼 때는 앞에서만 꺼냄.
> * 선입선출 (FIFO) 특징을 가지는 선형 자료구조
* 큐의 동작 그림
* ![image](https://user-images.githubusercontent.com/55529455/154265211-95ec3aef-f023-4e79-a4d7-35e6a910edb3.png) ![image](https://user-images.githubusercontent.com/55529455/154265270-55946252-fb53-4de4-a036-8135888638b7.png)
> * 큐의 추상적 자료구조 구현
> 1. 배열을 이용한 구현 -> Python 리스트와 함수를 사용함.
> 2. 연결 리스트를 이용하여 구현 -> 저번 시간에 배운 양방향 연결리스트
> * 큐의 시간복잡도
> * size() - 크기구하는 함수 - O(1)
> * isEmpty() - 비어있는지 확인하는 함수 - O(1)
> * enqueue() - 삽입하는 함수 - O(1)
> * dequeue() - 삭제하는 함수 - O(N)
> * peek() - 맨 앞의 자료를 불러오는 함수 - O(1)

### ● 15강 요약 (환형 큐)
> * 큐는 데이터 원소를 한 줄로 늘어세우는 자료구조
> * 자료를 보관할 수 있는 선형 구조
> * 단, 넣을 때는 뒤쪽에서 밀어넣고, 꺼낼 때는 앞에서만 꺼냄.
![image](https://user-images.githubusercontent.com/55529455/154473156-51d3b375-94b7-4d04-b471-e5e3ed55a374.png)
> * 즉, front를 이용하여 빈자리를 확인하고, rear를 이용하여 빈 자리에 넣을 자리를 확인한다.
> * 환형 큐를 구현하면서 연결리스트 형식으로도 구현 가능함.
> * 하지만, 선형 배열의 장점을 생각하자. -> 구현하기 쉽고, 메모리가 연속되기 때문에 환형 큐를 구현하기 쉬움.
> * 연결리스트의 경우는 연속된 데이터가 아니기 때문에, 구현 할 때 실수를 많이 할 수 있음. 또한, 노드가 끊기면, 해당 메모리를 접근하기 힘듬.

### ● 16강 요약 (우선순위 큐)
> * 큐는 데이터 원소를 한 줄로 늘어세우는 자료구조
> * 만약, 우선순위가 있다면? -> 자신이 원하는거 먼저 넣고 해결할 수 있음. -> 이는 시간 절약을 할 수 있게 됨.
> * 예시) 운영체제의 스케쥴링.
> * 우선순위를 구현하는 방법으로 크게 두가지로 나뉨.
> * 1. 큐에 원소를 넣을 때, 우선순위를 확인하여 정렬하는 방법
> * 2. 큐에서 꺼낼 때, 우선순위가 가장 높은 것을 선택 하는 것.
* 양방향 연결리스트를 이용하여 큐를 구현 하였을 때,
-> 원소를 넣을 때는 O(N)의 시간 복잡도가 걸리게 되므로, 큐의 길이에 비례하게 됨.
-> 원소를 뺄때는 O(1)이 걸리게 됨.
-> 이를 이용하여 알고리즘의 복잡도와 코딩의 편의성을 고려하여 2개의 방법 중 하나를 선택해야함.
-> 양방향 연결리스트의 경우는 1번의 방법이 유리함. -> 2번의 경우는 최악의 경우 O(N^2)이 될 수 있음. 1번의 경우는 최악이 O(N)이기 때문임.

### ● 17강 요약 (트리)
> * 여태까지는 1차원 자료형이고, 트리는 2차원 자료형임.
> * 정점(node)와 간선(edge)를 이용하여 데이터의 배치 형태를 추상화한 자료형.
> * 실제로 데이터베이스 시스템, 검색엔진에 많이 사용됨.
> * 트리는 말 그대로 나무를 생각하되, 거꾸로 되어있는 나무를 생각하자.
* 트리 용어 정리
```
노드 : 데이터
간선 : 노드와 노드가 연결되어 있는 길
루트 노드 : 최상위 노드
리프 노드 : 자식노드가 없는 노드 (끝 노드) - 나무의 이파리 생각하자.
내부 노드 : 자식노드와 부모 노드가 있는 노드 - 나무의 가지 생각하자.
부모 노드 : 자식 노드를 가지는 노드 (자신의 하위 노드가 있음)
자식 노드 : 부모 노드를 가지는 노드 (자신의 상위 노드가 있음)
노드의 수준(level) : 루트를 시작으로 자식노드로 갈 수록, 1 level이 상승함. - 특정 깊이를 가지는 노드의 집합
노드의 차수(degree) : 자식 노드의 개수
노드의 높이(depth) : 해당 노드까지 가는데 걸리는 간선의 개수.
트리의 차수(degree) : 트리가 가지는 노드의 최대 차수
트리의 높이(depth) : 루트 노드에서 가장 깊숙히 있는 노드의 깊이
```
> * 이진트리 = 자식을 최대 2개 가지는 트리를 의미함. -> 자식이 1개 있어도 이진 트리임. 3개 이상부터 안됨. 비어있어도 가능함.
> -> 루트노드 + 왼쪽 서브트리 + 오른쪽 서브트리 (서브트리는 모두 이진트리어야 함.)
> * 포화 이진 트리 = 모든 노드가 (리프 노드 제외) 자식을 2개씩 가지는 트리 (모든 레벨에서 노드들이 모두 채워져 있는 이진 트리)
> * 완전 이진 트리 = 리프 노드의 부모가 1~2개의 자식을 가지고 나머지는 모두 2개의 자식을 가지는 트리
> * 높이가 k인 완전 이진트리
> -> 레벨 k-2 까지는 모든 노드가 2개의 자식을 가진 포화 이진 트리. 레벨 k-1에서는 왼쪽부터 노드가 순차적으로 채워져 있어야 함.

### ● 18강 요약 (이진 트리)
> * 이진트리 = 모든 노드의 차수가 2 이하인 트리.
> ![image](https://user-images.githubusercontent.com/55529455/154479648-57a6bca1-ca3c-4636-b7a0-d2526347943c.png)
> * size() = 현재 트리에 포함되어 있는 노드의 수, depth() = 현재 트리의 깊이 (height)를 구함.
> * 트리는 정의 자체가 재귀적이기 때문에, 모든 함수들은 재귀적으로 작성이 가능함.
> * 순회 = 이진 트리의 모는 노드를 방문하는 일
> * 순회하는 방법으로 dft(깊이 우선 순회), bft(너비 우선 순회)가 있음.
* 깊이 우선 순회의 종류
> * 중위 순회 (in-order traverasl): 왼쪽 서브트리를 순회한 뒤 노드 x 를 방문, 그리고 나서 오른쪽 서브트리를 순회
> * 전위 순회 (pre-order traversal): 노드 x 를 방문한 후에 왼쪽 서브트리를 순회, 마지막으로 오른쪽 서브트리를 순회
> * 후위 순회 (post-order traversal): 왼쪽 서브트리를 순회, 오른쪽 서브트리를 순회, 그리고 나서 마지막으로 노드 x 를 방문
